# 梦开始的地方

## 一、基础配置

### 1.1 swagger配置

> ​	**注解说明**

- 定义在接口类上：@Api
- 定义在接口方法上：@ApiOperation
- 定义在接口方法上：@ApiImplicitParam（单个参数说明）
- 定义在接口方法上：@ApiImplicitParams （多个参数说明）
- 定义在实体类：@ApiModel（说明某个对象）
- 定义在实体类属性上：@ApiModelProperty（说明某个对象的属性）

<img src="../assets/image-20220617095149022.png" alt="image-20220617095149022" style="zoom:67%;" />



> ​	**添加依赖**

```xml
<!--版本问题-->
<!--swagger2 -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>
<!--swagger-ui -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>

<!--swagger-bootstrap-ui -->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>swagger-bootstrap-ui</artifactId>
    <version>1.9.6</version>
</dependency>



<!--swagger3配置-->
		<dependency>
			<groupId>org.springframework.plugin</groupId>
			<artifactId>spring-plugin-core</artifactId>
			<version>2.0.0.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.plugin</groupId>
			<artifactId>spring-plugin-metadata</artifactId>
			<version>2.0.0.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-boot-starter</artifactId>
			<version>3.0.0</version>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.plugin</groupId>
					<artifactId>spring-plugin-core</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.springframework.plugin</groupId>
					<artifactId>spring-plugin-metadata</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

<!--离线下载引入pom-->
	<dependency>
			<groupId>com.github.xiaoymin</groupId>
			 <artifactId>knife4j-spring-boot-starter</artifactId>
			 <version>3.0.2</version>
		</dependency>

<!--加入依赖后要访问下面的地址-->
http://localhost:8080/doc.html
```



> ​	**添加配置文件**

```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    /**
     * swagger会帮助我们生成接口文档
     * 1.配置生成的文档信息
     * 2.配置生成的规则
     * @return
     */

    /*Docket封装接口信息文档*/
    @Bean
    public Docket getDocket(){
        //指定文档风格
        ApiInfoBuilder apiInfoBuilder =new ApiInfoBuilder();
        apiInfoBuilder.title("..系统..")
                .description("...接口文档...")
                .version("version 1.0")
                .contact(new Contact("kirsten_li","http://www.li.com","li@qq.com"));
        ApiInfo apiInfo = apiInfoBuilder.build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
            	.groupName("webApi")
                .apiInfo(apiInfo)
                .select()
            .apis(RequestHandlerSelectors.basePackage("com.study.api.controller"))
                .paths(PathSelectors.any())
            	.paths(Predicates.not(PathSelectors.regex("/admin/.*")))
                .build();
        return docket;
    }
}



/**
	swagger3配置
*/
@Configuration
@EnableOpenApi //注解启动用Swagger的使用，同时在配置类中对Swagger的通用参数进行配置
public class Swagger3Config {
    @Bean
    public Docket createRestApi(){
         //返回文档概要信息
        return new Docket(DocumentationType.OAS_30)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.withMethodAnnotation(Operation.class))
                .paths(PathSelectors.any())
                .build()
                .globalRequestParameters(getGlobalRequestParameters())
                .globalResponses(HttpMethod.GET,getGlobalResponseMessage())
                .globalResponses(HttpMethod.POST,getGlobalResponseMessage());
    }

    /*
    生成接口信息，包括标题，联系人等
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("Swagger3接口文档")
                .description("如有疑问,可联系百度")
                .contact(new Contact("李白","http://www.baidu.com","baidu@qq.com"))
                .version("1.0")
                .build();
    }


    /*
    封装全局通用参数
     */
    private List<RequestParameter> getGlobalRequestParameters() {
        List<RequestParameter> parameters=new ArrayList<>();
        parameters.add(new RequestParameterBuilder()
                .name("uuid")
                .description("设备uuid")
                .required(true)
                .in(ParameterType.QUERY)
                .query(q->q.model(m->m.scalarModel((ScalarType.STRING))))
                .required(false)
                .build());

        return parameters;
    }
    /*
    封装通用相应信息
     */
    private List<Response> getGlobalResponseMessage() {
        List<Response> responseList=new ArrayList<>();
        responseList.add(new ResponseBuilder().code("404").description("未找到资源").build());
        return responseList;
    }
}
```



> ​	**在启动类添加swagger注解**

```java
在启动类上加
@ComponentScan(basePackages = {"com.demo"}) //com.demo是配置类文件所在
```



> ​	**swagger无法启动问题**

```properties
#springboot2.6.0以上要在properties/yaml配置
spring.mvc.pathmatch.matching-strategy=ant_path_matcher

# 生产环境需设置为false
springfox.documentation.swagger-ui.enabled=true

```



### 1.2  spring boot依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <modules>
        <module>common</module>
    </modules>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.8</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.demo</groupId>
    <artifactId>shangyitong</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>shangyitong</name>
    <description>shangyitong</description>
    <packaging>pom</packaging>

    <properties>
        <java.version>1.8</java.version>
        <cloud.version>2021.0.3</cloud.version>
        <alibaba.version>2021.0.1.0</alibaba.version>
        <mybatis-plus.version>3.5.1</mybatis-plus.version>
        <mysql.version>5.1.47</mysql.version>
        <swagger.version>2.9.2</swagger.version>
        <swagger-bootstrap-ui.version>1.9.6</swagger-bootstrap-ui.version>
        <jwt.version>0.9.1</jwt.version>
        <fastjson.version>2.0.7</fastjson.version>
        <httpclient.version>4.5.13</httpclient.version>
        <easyexcel.version>3.1.1</easyexcel.version>
        <aliyun.version>4.6.0</aliyun.version>
        <oss.version>3.15.0</oss.version>
        <jodatime.version>2.10.14</jodatime.version>
    </properties>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>

            <!--spring cloud-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--mybatis-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>
            <!--mysql-connector-->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
            </dependency>
            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger-ui-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger-bootstrap-ui -->
            <dependency>
                <groupId>com.github.xiaoymin</groupId>
                <artifactId>swagger-bootstrap-ui</artifactId>
                <version>${swagger-bootstrap-ui.version}</version>
            </dependency>
            <!--jwt-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jwt.version}</version>
            </dependency>
            <!--httpclient-->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>${httpclient.version}</version>
            </dependency>
            <!--fastjson-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>
            <!--easyexcel-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>${easyexcel.version}</version>
            </dependency>

            <!--aliyun-->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>${aliyun.version}</version>
            </dependency>
            <!--aliyun-sdk-oss-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${oss.version}</version>
            </dependency>
            <!--joda-time-->
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>${jodatime.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

```



### 1.3 properties与yaml

> **properties 配置**

```properties
# 服务端口
server.port=8007
# 服务名
spring.application.name=service-order

# mysql数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8
spring.datasource.username=root
spring.datasource.password=root

#返回json的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

#配置mapper xml文件的路径
mybatis-plus.mapper-locations=classpath:com/demo/order/mapper/xml/*.xml

#mybatis日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# nacos服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

#开启熔断机制
#feign.hystrix.enabled=true
# 设置hystrix超时时间，默认1000ms
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=3000
```





### 1.4 日志配置

> **在启动类上添加注解**

```properties
@sfl4j
```



> **添加logback-spring.xml配置文件**

```properties
<?xml version="1.0" encoding="UTF-8"?>
<configuration  scan="true" scanPeriod="10 seconds">
    <!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 -->
    <!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true -->
    <!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->
    <!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->

    <contextName>logback</contextName>
    <!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 -->
    <property name="log.path" value="D:/CodeManager/springboot-log" />

    <!-- 彩色日志 -->
    <!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 -->
    <!-- magenta:洋红 -->
    <!-- boldMagenta:粗红-->
    <!-- cyan:青色 -->
    <!-- white:白色 -->
    <!-- magenta:洋红 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) 	|%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"/>


    <!--输出到控制台-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息-->
        <!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>
        <encoder>
            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>
            <!-- 设置字符集 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>


    <!--输出到文件-->

    <!-- 时间滚动输出 level为 INFO 日志 -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_info.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录info级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 时间滚动输出 level为 WARN 日志 -->
    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_warn.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录warn级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>warn</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <!-- 时间滚动输出 level为 ERROR 日志 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_error.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录ERROR级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!--
        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。
        <logger>仅有一个name属性，
        一个可选的level和一个可选的addtivity属性。
        name:用来指定受此logger约束的某一个包或者具体的某一个类。
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，
              如果未设置此属性，那么当前logger将会继承上级的级别。
    -->
    <!--
        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：
        第一种把<root level="INFO">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息
        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：
     -->
    <!--开发环境:打印控制台-->
    <springProfile name="dev">
        <!--可以输出项目中的debug日志，包括mybatis的sql日志-->
        <logger name="com.guli" level="INFO" />

        <!--
            root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性
            level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG
            可以包含零个或多个appender元素。
        -->
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="INFO_FILE" />
            <appender-ref ref="WARN_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </root>
    </springProfile>


    <!--生产环境:输出到文件-->
    <springProfile name="pro">

        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="DEBUG_FILE" />
            <appender-ref ref="INFO_FILE" />
            <appender-ref ref="ERROR_FILE" />
            <appender-ref ref="WARN_FILE" />
        </root>
    </springProfile>

</configuration>
```



### 1.5 返回结果配置

> 添加接口

```java
public interface ResultVO {
    public static Integer SUCCESS = 1000; //成功

    public static Integer ERROR = 1001; //失败

}
```



> 添加类

```java 
@Data
public class Result {

    @ApiModelProperty(value = "是否成功")
    private Boolean success;

    @ApiModelProperty(value = "返回码")
    private Integer code;

    @ApiModelProperty(value = "返回消息")
    private String message;

    @ApiModelProperty(value = "返回数据")
    private Map<String,Object> data = new HashMap<>();

    private Result(){ }

    public static Result ok(){
        Result result = new Result();

        result.setSuccess(true);
        result.setCode(ResultVO.SUCCESS);
        result.setMessage("成功");
        return result;
    }

    public static Result error(){
        Result result = new Result();

        result.setSuccess(true);
        result.setCode(ResultVO.ERROR);
        result.setMessage("失败");
        return result;
    }

    public Result success(Boolean success){
        this.setSuccess(success);
        return this;
    }
    public Result message(String message){
        this.setMessage(message);
        return this;
    }
    public Result code(Integer code){
        this.setCode(code);
        return this;
    }
    public Result data(String key,Object value){
        this.data.put(key,value);
        return this;
    }
    public Result data(Map<String,Object> map){
        this.setData(map);
        return this;
    }
}
```





## 二、Spring Cloud

> 官方文档

中文文档：https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/zh-cn/index.html

英文文档：https://spring-cloud-alibaba-group.github.io/github-pages/2021/en-us/index.html



> ​	spring cloud的版本必须与 spring boot的版本相对应

```xml
<!--springboot版本2.6.8-->
<dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-dependencies</artifactId>
     <version>2021.0.3</version>
     <type>pom</type>
     <scope>import</scope>
</dependency>

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
    <version>2021.0.1.0</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
```

![](https://raw.githubusercontent.com/kristenli0116/repo/main/img/cloud%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE.png)

### 2.1SpringCloud Alibaba Nacos

> 服务注册与配置中心

**作用：**

- 替代Eureka做服务替代中心
- 替代Config做配置中心

> 下载：https://github.com/alibaba/nacos/releases/download/2.0.3/nacos-server-2.0.3.zip



```xml
<--第一步 引入依赖-->
<!-- 在使用nacos时要导入-->
<!--spring-cloud-starter-loadbalancer -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    <version>3.1.3</version>
</dependency>
<!--服务注册-->
<!-- htspring-cloud-starter-alibaba-nacos-discovery -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    <version>${discovery.version}</version>
</dependency>

<!--服务调用-->
<!-- spring-cloud-starter-openfeign -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
    <version>3.1.1</version>
</dependency>

<--第二步 配置application文件-->
<!--nacos服务地址-->
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

<--第三步 在启动类添加注解-->
    <!--启动nacos-->
@EnableDiscoveryClient
    <!--远程调用 在被调用类上面加注解-->
@EnableFeignClients

```

> ​	创建远程调用接口 

```java
@FeignClient(name = "service-center")
@Component
public interface UcenterClient {

    //根据用户id，获取用户信息
    @PostMapping("/center/member/getUserInfoOrder/{userId}")  //完全路径
    
    /*@PathVariable("userId") 必须在PathVariable后加上参数*/
    public MemberOrder getUserInfoOrder(@PathVariable("userId") String userId);
}
```



### 2.2 SpringCloud Alibaba Sentinel

> 官方文档：https://sentinelguard.io/zh-cn/

- sentinel 是基于Hystrix的Alibaba版，具有流量控制、服务降级、服务熔断且本省具有良好的可视化页面

  

> 下载：https://github.com/alibaba/Sentinel/releases/download/1.8.2/sentinel-dashboard-1.8.2.jar



- 服务降级：fallback

```java
//豪猪哥
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT" ,fallback = PaymentFallbackService.class)
public xxx interface{
  远程调用的服务方法
    @GetMapping("远程调用的方法的地址")
    // PathVariable中要加参数
    public 类型 方法名(@PathVariable("id") Integer id)；
}


//sentinel
```



- 服务熔断：相当于保险丝，进行服务降级

```java
 //=====服务熔断----豪猪哥
    @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties = {
            @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),// 是否开启断路器
            @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),// 请求次数
            @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"), // 时间窗口期
            @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"),// 失败率达到多少后跳闸
    })
```



- 服务限流：

```xml
<-- 第一步 配置依赖  豪猪哥 -->
<!-- spring-cloud-starter-netflix-hystrix -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    <version>2.2.10.RELEASE</version>
</dependency>

```



### 2.3 SpringCloud Alibaba Geteway

- 路由:route



- 断言：predicate,即匹配规则

  - After Route Predicate

  ```java
  spring:
    application:
      name: cloud-gateway
  cloud:
      gateway:
        discovery:
          locator:
            enabled: true #开启从注册中心动态创建路由的功能
  routes:
  - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
  # uri: http://localhost:8001          #匹配后提供服务的路由地址
  uri: lb://cloud-payment-service #匹配后提供服务的路由地址
  predicates:
  - Path=/payment/get/**         # 断言，路径相匹配的进行路由
  
  - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
  # uri: http://localhost:8001          #匹配后提供服务的路由地址
  uri: lb://cloud-payment-service #匹配后提供服务的路由地址
  predicates:
  - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
  
  - After=2020-02-05T15:10:03.685+08:00[Asia/Shanghai]         # 断言，路径相匹配的进行路由
  ```

  - Before Route Predicate
  - Between Route Predicate
  - Cookie Route Predicate
  - Header Route Predicate
  - Host Route Predicate
  - Method Route Predicate
  - Path Route Predicate
  - Query Route Predicate
  - All



- 过滤：filter

  

### 2.4 SpringCloud Alibaba Seata

> 官方网址：https://seata.io/zh-cn/

> 下载地址：https://github.com/seata/seata/releases

- 详细内容见官方文档。







## 三、MyBatis Plus

> 官网网站：https://baomidou.com/



### 3.1 MyBatis Plus 注解

```java
	TableID(type = typeId.)
  private Integer id;
```



#### 3.1.1 自动填充

> **自动填充(适用create_time、update_time)**

```properties
@TableFile(fill = FiledFill.INSERT)
private Date createTime;

@TableFile(fill = FiledFill.INSERT_UPDATE)
private Date updateTime;
```

> **在handler包下创建MyMetaObjectHandler类**

```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

		//mp执行添加操作，这个方法执行
    @Override
    public void insertFill(MetaObject metaObject) {
        //属性名，不是字段名
        this.setFieldValByName("createTime",new Date(),metaObject);//创建时间
        this.setFieldValByName("updateTime",new Date(),metaObject);//更新时间
      	this.setFieldValByName("version",1,metaObject);//乐观所
				this.setFieldValByName("deleted",0,metaObject);//逻辑删除
    }

		//mp执行修改操作，这个方法执行
    @Overrid
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("updateTime",new Date(),metaObject);
    }
}
```



#### 3.1.2 MP乐观锁

> **在表添加字段作为版本号，在表对应实体类添加版本号属性**

```java
@version
@TableFile(fill = FiledFill.INSERT)
private Integer version;
```



> **在MyMetaObjectHandler类中添加**

```java
this.setFieldValByName("version",1,metaObject);
```



> **配置乐观所插件**

创建config包，在包下创建MyConfig类

```java
// 乐观锁插件
@Bean
public OptimisticLockerInterceptor optimisticLockerInterceptor(){
  return new OptimisticLockerInterceptor();
} 
  
```



#### 3.1.3 分页查询

> **在MyConfig类中添加插件**

```java
// 分页插件
@Bean
public PaginationInterceptor paginationInterceptor(){
  return new PaginationInterceptor();
}
```

> **编写分页代码**

```java
Page<T> page = new Page<>(`current`:1,`size`:3);
Page<T> Tpage = TMapper.selectPage(page,`QueryWrapper`:null);
//返回对象的到分页所有数据
long pages = Tpage.getPages();						//总页数
long current = Tpage.getCurrent();				//当前页
List<T> records = Tpage.getRecords();			//查询数据集合
long total = Tpage.getTotal();						//总记录数
boolean hasNext = Tpage.hasNext();				//下一页
boolean hasPrevious = Tpage.hasPrevious();//上一页

```

#### 3.1.4 逻辑删除

> **添加逻辑删除字段**

```java
@Tablelogic
@TableField(fill = FieldFill.INSERT)
private Integer deleted;
```

> **在MyMetaObjectHandler类中添加**

```java
this.setFieldValByName("deleted",0,metaObject);
```



### 3.2 Wrapper 介绍

> QueryWrapper

```java
QueryWrapper<T> wrapper = new QueryWrapper<>();
wrapper.eq() .gt() .le() .lt()
  			.between .notBetween
  			.like .notlike .leftLike .LikeRight
  			.orderBy .orderByDesc .orderByEsc
```



### 3.3 MyBatisPlus代码生成器

- 详细配值见：https://baomidou.com/pages/981406/



> **引入Mybatis Plus代码生成器所需依赖**

```xml
<dependency>
  <groupId>org.projectlombok</groupId>
  <artifactId>lombok</artifactId>
</dependency>
<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
</dependency>
<dependency>
  <groupId>com.baomidou</groupId>
  <artifactId>mybatis-plus-boot-starter</artifactId>
  <version>3.5.2</version>
</dependency>
<dependency>
  <groupId>com.baomidou</groupId>
  <artifactId>mybatis-plus-generator</artifactId>
  <version>3.5.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-freemarker -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-freemarker</artifactId>
  <version>2.7.0</version>
</dependency>
<dependency>
  <groupId>io.springfox</groupId>
  <artifactId>springfox-swagger2</artifactId>
  <version>2.9.2</version>
</dependency>
<dependency>
  <groupId>com.github.xiaoymin</groupId>
  <artifactId>swagger-bootstrap-ui</artifactId>
  <version>1.9.6</version>
</dependency>
<dependency>
  <groupId>io.springfox</groupId>
  <artifactId>springfox-swagger-ui</artifactId>
  <version>2.9.2</version>
</dependency>

```



> **test中创建CodeGenerator文件**

```java
//最新版
  FastAutoGenerator.create("jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=Asia/Shanghai", "root", "abc123")
                .globalConfig(builder -> {
                    builder.author("lkx") // 设置作者
                            .enableSwagger() // 开启 swagger 模式
                            .fileOverride() // 覆盖已生成文件
                            .outputDir("src\\main\\java"); // 指定输出目录
                })
                .packageConfig(builder -> {
                    builder.parent("com.example") // 设置父包名
                            .moduleName("demo") // 设置父包模块名
                            .pathInfo(Collections.singletonMap(OutputFile.xml, "src\\main\\resources\\mapper")); // 设置mapperXml生成路径
                })
                .strategyConfig(builder -> {
                    builder.addInclude("t_product") // 设置需要生成的表名
                            .addTablePrefix("t_", "c_") // 设置过滤表前缀
                            //实体类
                            .entityBuilder()
                            .enableLombok() // 开启 lombok 模型
                            .enableTableFieldAnnotation()//开启生成实体时生成字段注解
                            .naming(NamingStrategy.no_change)//数据库表映射到实体的命名策略,默认下划线转驼峰命名:NamingStrategy.underline_to_camel

                           //service
                            .serviceBuilder()
                            .formatServiceFileName("%sService")//格式化 service 接口文件名称
                            .formatServiceImplFileName("%sServiceImp")//格式化 service 实现类文件名称

                           //controller
                            .controllerBuilder()
                            .enableRestStyle()//开启生成@RestController 控制器

                            //mapper
                            .mapperBuilder()
                            .enableBaseResultMap()//启用 BaseResultMap 生成
                            .enableMapperAnnotation()//开启 @Mapper 注解
                            .enableBaseColumnList();//启用 BaseColumnList
                })
                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                .execute();
    }



旧版
public class CodeGenerator {

    @Test
    public void run() {

        // 1、创建代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 2、全局配置
        GlobalConfig gc = new GlobalConfig();
        //String projectPath = System.getProperty("user.dir");
        gc.setOutputDir("D:\\Program Files (x86)\\JetBrains\\Workspace_idea\\项目名" + "/src/main/java");
        gc.setAuthor("testjava");
        gc.setOpen(false); //生成后是否打开资源管理器
        gc.setFileOverride(false); //重新生成时文件是否覆盖
        gc.setServiceName("%sService");	//去掉Service接口的首字母I
        gc.setIdType(IdType.ID_WORKER); //主键策略
        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型
        gc.setSwagger2(true);//开启Swagger2模式

        mpg.setGlobalConfig(gc);

        // 3、数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/数据库?serverTimezone=GMT%2B8");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("abc123");
        dsc.setDbType(DbType.MYSQL);
        mpg.setDataSource(dsc);

        // 4、包配置
        PackageConfig pc = new PackageConfig();
        pc.setModuleName("模块名"); //模块名
        pc.setParent("com.demo");
        pc.setController("controller");
        pc.setEntity("entity");
        pc.setService("service");
        pc.setMapper("mapper");
        mpg.setPackageInfo(pc);

        // 5、策略配置
        StrategyConfig strategy = new StrategyConfig();
        strategy.setInclude("数据库表名");
        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
        strategy.setTablePrefix(pc.getModuleName() + "_"); //生成实体时去掉表前缀

        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作

        strategy.setRestControllerStyle(true); //restful api风格控制器
        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符

        mpg.setStrategy(strategy);


        // 6、执行
        mpg.execute();
    }
}

```



## 四、RabbitMQ

> 下载与安装

```properties
####下载####
erlang-23.3.4.11-1.el7.x86_64.rpm

socat-1.7.3.2-2.el7.x86_64.rpm

rabbitmq-server-3.8.16-1.el7.noarch.rpm

####安装####
npm -ivh 上面三个包名

```



- 开启服务

```properties
systemctl start rabbitmq-server
```

- 停止服务

```properties
systemctl stop rabbitmq-server
```

- 重启服务

```properties
systemctl restart rabbitmq-server
```

- 查看状态

```properties
systemctl status rabbitmq-server
```

- 开机自动启动

```properties
systemctl enable rabbitmq-server
```

- 开启web管理插件

``` properties
 rabbitmq-plugins enable rabbitmq_management
```

**打开浏览器，输入 服务器id：15672** 



- 添加远程用户

```properties
# 添加用户
rabbitmqctl add_user 用户名 密码

# 设置用户角色,分配操作权限
rabbitmqctl set_user_tags 用户名 角色

# 为用户添加资源权限(授予访问虚拟机根节点的所有权限)
rabbitmqctl set_permissions -p / 用户名 ".*" ".*" ".*"

```

**角色有四种**：

- `administrator`：可以登录控制台、查看所有信息、并对rabbitmq进行管理
- `monToring`：监控者；登录控制台，查看所有信息
- `policymaker`：策略制定者；登录控制台指定策略
- `managment`：普通管理员；登录控制



- 其他命令：

```properties
# 修改密码
rabbitmqctl change_ password 用户名 新密码

# 删除用户
rabbitmqctl delete_user 用户名

# 查看用户清单
rabbitmqctl list_users

```



### 4.1 RabbitMQ应用案例

**生产者:消费者（1:1）**

> :sunny: 一个生产者一个消费者

- 生产者

```java
package com.demo.rabbitmq.one;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * @auther lkx
 * @create 2022-07-01 17:07
 * @Description:
 */
public class Product {

    public static final String QUEUE_NAME="hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //工厂IP 连接RabbitMQ的队列
        factory.setHost("192.168.33.100");
        //用户名
        factory.setUsername("lilili");
        //密码
        factory.setPassword("abc123");
        //创建连接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();

        channel.queueDeclare(QUEUE_NAME,false,false,false,null);

        String message = "hello world";

        channel.basicPublish("",QUEUE_NAME,null,message.getBytes(StandardCharsets.UTF_8));

        System.out.println("消息发送成功");

    }
}

```

- 消费者

```java
package com.demo.rabbitmq.one;

import com.rabbitmq.client.*;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @auther lkx
 * @create 2022-07-01 17:26
 * @Description:
 */
public class Consumer {

    public static final String QUEUE_NAME="hello";

    public static void main(String[] args) throws IOException, TimeoutException {
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //工厂IP 连接RabbitMQ的队列
        factory.setHost("192.168.33.100");
        //用户名
        factory.setUsername("lilili");
        //密码
        factory.setPassword("abc123");
        //创建连接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();

        // 声明 接受消息
        DeliverCallback deliverCallback = (consumerTag,message) ->{
            System.out.println(message);
        };

        //取消消息时的回调
        CancelCallback cancelCallback = consumerTag ->{
            System.out.println("消息消费被中断");
        };

        channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);
    }
}

```





**生产者:消费者（1:N)**

>  :sunny: 一个生产者与多个消费者:多个消费者之间采用“轮询”的方式进行消费。

- 工具类

   :sunny: 将连接RabbitMQ的部分提取为公共的工具类

```java
package com.demo.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

/**
 * @auther lkx
 * @create 2022-07-04 14:31
 * @Description:
 */
public class RabbitMqUtils {
    //得到一个连接的channel
    public static Channel getChannel() throws Exception {
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //工厂IP 连接RabbitMQ的队列
        factory.setHost("192.168.33.100");
        //用户名
        factory.setUsername("lilili");
        //密码
        factory.setPassword("abc123");
        //创建连接
        Connection connection = factory.newConnection();
        //获取信道
       Channel channel = connection.createChannel();

        return channel;
    }
}

```



- 生产者

```java
package com.demo.rabbitmq.three;

import com.demo.rabbitmq.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

/**
 * @auther lkx
 * @create 2022-07-04 15:45
 * @Description:
 */
public class ProductThree {

    public static final String ACK_QUEUE_NAME = "ack_hello";

    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();

        //声明队列
        boolean durable = true;
        channel.queueDeclare(ACK_QUEUE_NAME,durable,false,false,null);
        //在控制台输入消息
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()){
            String message = scanner.next();
            channel.basicPublish("",ACK_QUEUE_NAME,null,message.getBytes(StandardCharsets.UTF_8));
            System.out.println("生产者发出消息:" + message);
        }

    }
}

```

- 消费者1号

```java
/**
 * @auther lkx
 * @create 2022-07-04 15:45
 * @Description: 消费者1号
 */
public class Consumer01 {
    public static final String ACK_QUEUE_NAME = "ack_hello";

    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        System.out.println("消费者1号等待接受消息时间较短");

        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) ->{
            //睡眠1秒
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("接收到消息："+ new String(message.getBody(),"UTF-8"));
            //手动应答
            /**
             * 1. 消息的标记 tag
             * 2. 是否批量应答 false OR true
             */
        };

        CancelCallback cancelCallback = consumerTag ->{
            System.out.println("消费者取消消费接口回调逻辑");
        };

        //采用手动应答
        boolean autoAck = false;
        channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);
    }
}

```

- 消费者2号

```java
/**
 * @auther lkx
 * @create 2022-07-04 15:45
 * @Description: 消费者2号
 */
public class Consumer02 {
    public static final String ACK_QUEUE_NAME = "ack_hello";

    public static void main(String[] args) throws Exception {
        Channel channel = RabbitMqUtils.getChannel();
        System.out.println("消费者2号等待接受消息时间较长");

        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -> {
            //睡眠1秒
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("接收到消息：" + new String(message.getBody(), "UTF-8"));
            //手动应答
            /**
             * 1. 消息的标记 tag
             * 2. 是否批量应答 false OR true
             */
        };

        CancelCallback cancelCallback = consumerTag -> {
            System.out.println("消费者取消消费接口回调逻辑");
        };
        //采用手动应答
        //采用手动应答
        boolean autoAck = false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);
    }
}

```









### 4.2 RabbitMQ 持久化

#### 4.2.1 消息持久化

> 在声明队列中将durable 的值变为 true



**在生产者中进行修改**

- 转变前：

```java
//声明队列
channel.queueDeclare(ACK_QUEUE_NAME,false,false,false,null);
 //设置生产者发送消息为持久化消息（要求保存到磁盘上）保存到内存中
channel.basicPublish("",ACK_QUEUE_NAME,false,message.getBytes(StandardCharsets.UTF_8));
           
```

- 转变后：

```java
//声明队列
boolean durable = true;
channel.queueDeclare(ACK_QUEUE_NAME,durable,false,false,null);

 //设置生产者发送消息为持久化消息（要求保存到磁盘上）保存到内存中
channel.basicPublish("",ACK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(StandardCharsets.UTF_8));
```

- 报错

  原因：之前的序列存在，不是持久化序列。将之前的序列删除，重新运行程序

```java
Caused by: com.rabbitmq.client.ShutdownSignalException: 
channel error; protocol method: #method<channel.close>
  (reply-code=406, 
   reply-text=PRECONDITION_FAILED - inequivalent arg 'durable' for queue 'ack_hello' in vhost '/': 
   received 'true' but current is 'false', class-id=50, method-id=10)
```



#### 4.2.2 不公平分发

- 轮询分发
  - 不公平
  - 能力高的与能力低的拿的工资一样

- 不公平分发
  - 能者多劳，多劳多得

```java
//设置不公平分发
int prefetchCount = size;
channel.basicQos(prefetchCount);

//采用手动应答
boolean autoAck = false;
channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);
```

prefetchCount: 在消费者中设置prefetchCount，size=（1,2,3…..）每一个消费者可以在信道中获取的消息的条数。



### 4.3 确认策略

- 单个确认
- 批量确认
- 异步确认

#### 4.3.1 单个确认

- 速度慢，但每个消息都能得到确认

```java
package com.demo.rabbitmq.four;

import com.demo.rabbitmq.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import java.nio.charset.StandardCharsets;
import java.util.UUID;

/**
 * @auther lkx
 * @create 2022-07-04 17:53
 * @Description:
 */
public class ProductFour {
    public static final int MESSAGE_COUNT = 1000;

    public static void main(String[] args) throws Exception {

        //1. 单个确认
        ProductFour.publishMessageIndividually();//发布1000条单独确认消息，耗时：1018ms
        //2. 批量确认

        //3. 异步确认
    }

    public static void publishMessageIndividually() throws Exception {
        Channel channel = RabbitMqUtils.getChannel();

        String queueName = UUID.randomUUID().toString();
        //声明队列
        channel.queueDeclare(queueName,true,false,false,null);
        //开启发布确认
        channel.confirmSelect();
        //开始时间
        long begin = System.currentTimeMillis();
        for (int i = 0; i < MESSAGE_COUNT; i++) {
            String message = i + "";
            channel.basicPublish("",queueName,null,message.getBytes(StandardCharsets.UTF_8));

            //单个消息马上开始消息确认
            boolean result = channel.waitForConfirms();
            if (result){
                System.out.println("消息发送成功");
            }
        }
        //结束时间
        long end = System.currentTimeMillis();

        System.out.println("发布"+MESSAGE_COUNT +"条单独确认消息，耗时：" + (end-begin) +"ms");
    }
}

```



#### 4.3.2 批量确认

- 速度快，但不能准确判断那一条数据出错了。

```java
package com.demo.rabbitmq.four;

import com.demo.rabbitmq.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

/**
 * @auther lkx
 * @create 2022-07-04 17:53
 * @Description:
 */
public class ProductFour {
    public static final int MESSAGE_COUNT = 1000;

    public static void main(String[] args) throws Exception {

        //1. 单个确认
        //ProductFour.publishMessageIndividually();//发布1000条单独确认消息，耗时：1018ms
        //2. 批量确认
        ProductFour.publishMessageBatch();//发布1000条批量确认消息，耗时：121ms
        //3. 异步确认
    }
  
 	 public static void publishMessageBatch() throws Exception {
        Channel channel = RabbitMqUtils.getChannel();

        String queueName = UUID.randomUUID().toString();
        //声明队列
        channel.queueDeclare(queueName,true,false,false,null);
        //开启发布确认
        channel.confirmSelect();
        //开始时间
        long begin = System.currentTimeMillis();

        int batchNum = 100;
        for (int i = 0; i < MESSAGE_COUNT; i++) {
            String message = i + "";
            channel.basicPublish("",queueName,null,message.getBytes(StandardCharsets.UTF_8));
          //每一百条确认一次
            if ((i +1 )%batchNum == 0 ){
                channel.waitForConfirms();
            }
        }
        //结束时间
        long end = System.currentTimeMillis();

        System.out.println("发布"+MESSAGE_COUNT +"条批量确认消息，耗时：" + (end-begin) +"ms");
    }
}
```



#### 4.3.3 异步确认

- 速度快，效率高，性能好

```java
package com.demo.rabbitmq.four;

import com.demo.rabbitmq.utils.RabbitMqUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConfirmCallback;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

/**
 * @auther lkx
 * @create 2022-07-04 17:53
 * @Description:
 */
public class ProductFour {
    public static final int MESSAGE_COUNT = 1000;

    public static void main(String[] args) throws Exception {

        //1. 单个确认
        //ProductFour.publishMessageIndividually();//发布1000条单独确认消息，耗时：1018ms
        //2. 批量确认
//        ProductFour.publishMessageBatch();//发布1000条批量确认消息，耗时：121ms
        //3. 异步确认
        ProductFour.publishMessageAsync();//发布1000条批量确认消息，耗时：77ms
    }

public static void publishMessageAsync() throws Exception {
        Channel channel = RabbitMqUtils.getChannel();

        String queueName = UUID.randomUUID().toString();
        //声明队列
        channel.queueDeclare(queueName,true,false,false,null);
        //开启发布确认
        channel.confirmSelect();
        //开始时间
        long begin = System.currentTimeMillis();

        //消息确认成功的回调函数
        /**
         * 1. deliveryTag 消息的标记
         * 2. multiple 是否为批量确认
         */
         ConfirmCallback ackCallback = (deliveryTag, multiple)->{
             System.out.println("确认的消息：" + deliveryTag);
         };
         //消息确认失败的回调函数
         ConfirmCallback nackCallback = (deliveryTag, multiple)->{
             System.out.println("未确认的消息："+deliveryTag);
         };

         //开启消息的监听器 ，监听成功、失败的消息
        /**
         * 1. 监听成功的消息
         * 2. 监听失败的消息
         */
       channel.addConfirmListener(ackCallback,nackCallback);

        for (int i = 0; i < MESSAGE_COUNT; i++) {
            String message = "消息" + i;
            channel.basicPublish("",queueName,null,message.getBytes(StandardCharsets.UTF_8));

        }
        //结束时间
        long end = System.currentTimeMillis();

        System.out.println("发布"+MESSAGE_COUNT +"条批量确认消息，耗时：" + (end-begin) +"ms");
    }

}
```



#### 4.3.4 如何处理异步未确认消息

- 第一步: 添加确认消息的map集合

```java
/**
* 线程安全有序的哈希表 适用于高并发情况下
         * 1. 键值对保存信息
         * 2. 通过键值批量删除信息
         * 3. 支持高并发
         */
//infoConfirmMap 消息确认集合
ConcurrentSkipListMap<Long,String> infoConfirmMap  = new ConcurrentSkipListMap<>();
```



- 第二部：将确认的消息放入map集合中

```java
for (int i = 0; i < MESSAGE_COUNT; i++) {
  String message = "消息" + i;
  channel.basicPublish("", queueName, null, message.getBytes(StandardCharsets.UTF_8));

  //1. 将确认的消息放入 infoConfirmMap 集合中 ------》第二步 见：110行
  infoConfirmMap.put(channel.getNextPublishSeqNo(),message);
}
```



- 第三部：将map中确认的消息清除, 修改 ackCallback 和 nackCallback

```java
ConfirmCallback ackCallback = (deliveryTag, multiple) -> {
  //判断是否是批量
  if (multiple){
    //2. 获得确认消息的编号
    ConcurrentNavigableMap<Long,String> headMap = infoConfirmMap.headMap(deliveryTag);
    //通过clear()全部清除
    headMap.clear();
  }else {
    //不是批量，通过remove清除
    infoConfirmMap.remove(deliveryTag);
  }
  System.out.println("确认的消息：" + deliveryTag);
};


ConfirmCallback nackCallback = (deliveryTag, multiple) -> {
  String message = infoConfirmMap.get(deliveryTag);
  System.out.println("未确认消息的编号：" + deliveryTag + "----未确认的消息" + message);
};
```



### 4.4 交换机

- 直接交换机（Direct）、扇出交换机（Funout）、主题交换机（Topics）



### 4.5 死信队列

**流程展示：**

![](../assets/Snipaste_2022-07-05_17-43-10.png)



**代码展示：**

```java
```





### 4.6 延迟队列



#### 4.6.1 基于插件实现

- 下载rabbitmq的插件

> 下载地址：https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases

进入Rabbitmq 插件目录

```shell
rabbitmq-plugins directories -s
```

将插件放在plugins插件目录下，运行插件。

```shell
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
```

重启RabbitMQ。

使用详情见 readme。





## 五、Redis

> redis = 单线程 +  多路IO应用

- string字符串、hash映射、list列表、set集合、zset无序集合物种数据类型。
- 特点：
  - 基于内存存储，数据读写效率高
  - redis本身支持持久化
  - redis虽然基于key-value存储，但是支持多种数据类型
  - redis支持集群、支持主从模式
- 优点
  - redis基于内存结构，性能极高
  - redis基于键值对存储，但是支持多种数据类型
  - redis的所有操作都是原子性，可以通过lua脚本将多个操作合并为以一个原子操作
  - redis是基于单线程操作，但是多路复用实现了高性能读写
- 缺点
  - 缓存数据与数据库必须通过两次写操作才能保持数据的一致性
  - 使用缓存会存在缓存穿透】缓存击穿及缓存雪崩等问题，需要处理
  - redis可以作为数据库使用进行数据的持久存储，存在丢失数据的风险

### 5.1 常用的五大数据类型

#### 5.1.1  基本命令

```shell
keys * 查看当前库中所有的key

exists key 半段某个key时候存在

type key 查看你的key是什么类型

del key 删除指定的key数据

unlink key 根据value选择非阻塞删除

仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作

expire key 10 10秒钟：为给定的keyt设置过期时间

ttl key 查看还有多少秒过期。-1 表示永不过期，-2 表示已过期

select 命令切换数据库

dbsize 查看当前数据库的key的数量

flushdb 清空当前库

flushall 通杀全部库
```

#### 5.1.2 string

> String类型是二进制安全

 **常用命令**

``` 
get key 查询对应键值 

append <key><value>将给定的<value>最佳到原值的末尾

strlen <key>获取值得长度

setnx  <key><value>只有在key不存在时 设置key的值

incr <key>	将key中存储的数字值增1，只能对数字值操作，如果为空，新增值为1

decr <key>	将key中的存储的数字值键1，只能对数字值操作，如果为空，新增值为-1

incrby/decrby <key><步长>将key中的存储的数字值增减

mset <key1><key2><key3>.... 同时设置一个或多个key-value对

mget <key1><key2><key3>.... 同时获取一个或多个value

msetnx <key1><value1><key2><value2>..... 
同时设置一个或多个key-value对，当且仅当所有给定的key都不存在

getrange <key><起始位置><结束位置> 获得值得范围，类似java中的substring，前包，后包

setrange <key><起始位置><value>	用<value>覆写<key>所存储的字符串的值，从<起始位置>开始（索引从0开始）

setex <key><过期时间><value>	设置键值的同时，设置过期时间，单位秒。

getset <key><value> 以新换旧，设置了新值同时获得旧值。
```

#### 5.1.3 List

 **常用命令**

```shell
lpush/rpush <key><value1><value2><value3>	从左边/右边插入一个或多个值

lpop/rpop <key>	从左边/右边吐出一个值。值在健在，值光键亡

rpoppush <key1><key2>从<key1>列表的右边吐出，插入到<key2>列表左边

lrange <key><start><stop>	按照索引下表获得元素（从左到右）

lrange mylist 0 -1	0左边第一个，-1右边第一个，0-1表示获取所有

lindex <key><index>	按照索引下表获得元素（从左到右）

llen <key> 获取列表长度

linsert <kye> before <value><newvalue>在<value>后面查出<newvalue>插入值

lrem <key><n><value>从左边删除n个value(从左到右)

lset<key><index><value>将列表key下标为index的值替换成value

```

#### 5.1.4 set

**常用命令**

```shell
sadd<key><value1><value2>......	讲一个或多个member元素加入到集合key中华，已经存在的member元素将被忽略

smembers <key>去除该集合的所有值

sismember <key><value>判断集合<key>是否含有改<value>值，有1，没有0

scard <key>返回该集合的元素个数。

srem <key><value1><value2>....删除集合中的某个元素值。

spop <key>随机从该集合中吐出一个值。

srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除。

smove <source><destination>value把集合中一个值从一个集合移动到另一个集合

sinter <key1><key2>返回连个集合的交集元素

sunion <key1><key2>返回两个集合的并集元素

sdiff <key1><key2>返回连个集合的差集元素（key1中的，不包含key2中的）

```

#### 5.1.5 hash

**常用命令**

```shell
hset <key><field><value>给<key>集合中的<field>赋值<value>

hget <key1><feild>从<key1>集合<field>取出value

hset <key1><field1><value1><field2><value2>....批量设置hash的值

hexists <key1><field>查看哈希表key中，给定域field是否存在

hkeys <key>列出改hash集合的所有field

hvals <key>列出该hash集合的所有value

hincrby	<key><field><increment>为哈希表key中的域field的值加上增量1，-1

hsetnx <key><field><value>将哈希表 key 中的域field的值设置为value，当且仅当域field不存在
```

#### 5.1.6 Zset（sorted set）

> 有序结构
>
> 底层结构------》跳跃表 ：查找更快

**常用命令**

```shell
zadd <key><score1><value><score2><value2>...将一或多个member元素以及其score值加入到有序集key当中

zrange <key><start><stop> [withscores]	返回有序集合key中，下表在<start><stop>之间的元素
带withscores，可以让分数和一起和值返回到结果集

zrangebyscore key minmax [withscores][limit offset count]	返回有序集key中，所有sorce值介于且包括min和max之间的成员。有续集成员按score值递增次序排列。

zrevrangebyscore key maxmin [withscores][limit offset count] 同上，改为从大到小排列。

zincrby <key><increment><value>	为元素score上加上增量

zrem <key><value>删除改集合下，指定值的元素

zcount <key><min><max>	统计该集合，分数区间的元素个数

zrank <key><value>	返回该值在集合中的排名，从0开始。


```

#### 5.1.7 Redis新数据类型

- Bitmaps

```shell
setbit <key><offset>

getbit <key><offset>

bitcount <key>[start end]统计字符串从start字节到end字节比特值为1的数量

bitop and(or/not/xor) <destkey> [key...] 	是一个符合操作，他可以做多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将其结果保存在destkey中



```

- HyperLogLog

```shell
针对与基数运算

pfadd <key><element>[element...]	添加加指定元素到HyperLogLog中

pfcount <key> [element]	统计key中的个数

pfmerge <destkey><sourcekey> [sourcekey...]	将一个或多个HLL合并后的结果存储来在另一个HLL中，比如每月活跃用户可以使用每天活跃用户合并来计算可得。

```

- Geospatial

```shell
针对地理信息计算

geoadd<key><longitude><latitude><member>[longitude latitude member...] 
添加地理位置（精度、维度、名称）

geolist<key><member1><member2> [m|km|ft|mi]
获取两个位置间的直线距离	m：米	km：千米 	mi：英里	ft：英尺	

georadius<key><longitude><latitude>radius m|km|ft|mi
已给定的经纬度为中心，找出某一半径内的元素 ： 经度 纬度 距离 单位


```

### 5.2 Redis 事务、锁机制、秒杀

#### 5.2.1 multi、Exec、discard

```shell
mutil命令开始-》Exec命令执行-》discard命令丢弃
组队阶段----》执行阶段----》
```

#### 5.2.2

#### 5.2.3 Redis事务的三特性

- 单独的隔离操作

> 事务中的所有命令都会序列化、按顺序地执行。书屋在执行的过程中，不会被其他客户端发送来的命令请求打断。

- 没有隔离级别的概念

> 队列中的命令没有提交之前都不会实际被执行，因为事务提交之前任何指令都不会被实际执行。

- 不保证原子性

> 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。

#### 5.2.4 秒杀



### 5.3 Redis 持久化之RDB



#### 5.3.1 RDB（Redis DataBase）

- 是什么

```shell
RDB:在既定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，他恢复时是将快照文件直接读到内存里

RDB缺点：最后一次持久化的数据可能丢失

```

- Fork

```shell
RDB持久化方式：通过创建一个Fork的子进程创建一个临时文件，把临时文件件替换出持久化的那个文件，用到的技术是写时复制技术

```

- 优势

```shell
适合大规模的数据恢复
对数据完整性和一致性要求高的，不适合用
节省磁盘空间
恢复速度快

```

- 劣势

```shell
Fork的时候，内存中的数据被克隆了一份大致两倍的膨胀性需要考虑

虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能

在备份周期在一定间隔时间做一次备份，如果Redis出意外down的话，就会丢失最后一次快照后的所有修改
```

#### 5.3.2 AOF（Append Only File）

- 是什么

```shell
以日志的形式来记录每一个写操作（增量保存）
读操作不记录
只允许追加文件但不可以改写文件
```

- AOF启动、修复

```shell
修复appendonly.aof
redis-check-aof --fix appendonly.aof 
```

- AOF同步频率设置

```shell
appendfsync always
始终同步，每次Redis的写入都会李可记入日志；性能较差但数据完整性比较好

appendfsync everysec
每秒同步，美妙记入日志一次，如果宏机，本秒的数据可能丢失。

appendfsync no
Redis不主动进行同步，把同步时机交给操作系统
```

- 优势

```shell
备份机制更文件，对视数据概率更低

可读的日志文本，通过操作AOF文件，可以处理误操作
```

- 劣势

```shell
比起RDB占用更多的磁盘空间

恢复备份速度要慢

每次读写都同步的话，有一定的性能压力。

存在个别Bug，造成恢复不能。
```



### 5.4 主从复制

#### 5.4.1 是什么

```shell
master、slave：master一写为主、slave以读为主

读写分离，性能扩展

容灾的快速恢复

slaveof no one 将从机变成主机
```

#### 5.4.2 哨兵模式（sentinel）

```shell
sentinel monitor mymaster（为监控对象起的服务器名称） 127.0.0.1 6379  1（哨兵数量）
```







##  六 、Docker

官方文档：https://dockerdocs.cn/engine/install/centos/



配置阿里云镜像：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors

### 6.1 命令

#### 6.1.1 帮助启动类命令

```properties
启动docker: systemctl start docker

停止docker: systemctl stop docker

重启docker: systemctl restart docker

查看docker状态: systemctl status docker

开机启动: systemctl enable docker

查看docker概要信息: docker info

查看docker总体帮助文档: docker --help

查看docker命令帮助文档: docker 具体命令 --help

```

### 6.2 镜像命令

```properties
docker images [选项]  列出本地主机镜像
	[选项]	-a
```

| 选项       | 说明             |
| ---------- | ---------------- |
| REPOSITORY | 表示镜像的仓库源 |
| TAG        | 镜像的标签       |
| IMAGE ID   | 镜像id           |
| CREATED    | 镜像的创建时间   |
| SIZE       | 镜像大小         |

> 同一个仓库源可有多个TAG 版本，代表不同的版本。通常我们使用REPOSITORY:TAG  来定义不同的镜像。



```properties
#搜所镜像源
docker search 某个xxx镜像名字
docker search --limit 3  镜像名字 

#拉取镜像到本地
docker pull 镜像名字

#查看镜像所在卷
docker system df 查看镜像/容器/数据卷所占空间

#删除镜像
docker rmi [选项]某个xxx镜像名字id
	[选项]
	-f 镜像id									 删除单个
	-f 镜像名1:TAG 镜像名2:TAG 	删除多个
	-f $(docker images -qa)		删除全部
```

```properties
#运行容器
docker run -it centos /bin/bash
参数说明：
-name="???" 起名字
-i：交互式操作
-t：终端
-p：指定端口
-P：随机端口
-d；保护模式
centos：centos镜像。
/bin/bash：放在镜像名后的是命令，这里我们希望有个交互是式shell，因此使用/bin/bash。

#退出容器
exit 容器停止
ctrl+p+q 容器推出不停止

#重启容器
docker restart 容器ID或者容器名

#停止容器
docker stop 容器ID或者容器名

#强制停止容器
docker kill 

#删除已停止容器
docker rm 容器id

#启动保护容器
docker run -d 容器名

#导入
docker import 容器id
cat 文件1.tar | docker import -镜像用户/镜像名:版本号

#导出
docker export 容器id > 文件2.tar


#更新包管理工具
[root@hadoop100 docker]# docker run -it ubuntu
root@509790f9f9f5:/# apt-get update

#安装vim
root@509790f9f9f5:/# apt-get -y intall update
#安装net-tools
root@014a9c7f2d74:/# apt-get install net-tools


#提交
docker commit -m="vim cmd add ok" -a="hadoop100" 509790f9f9f5 root/myubuntu:1.3
																			主机名				imageID		用户名/镜像名：版本号

#卷---文档备份
docker run -it --privileged=true -v/宿主机绝对路径目录：/容器内目录 镜像名

docker run -d -p 5000（host主机）:5000（containerr） -v /zzyyuse/myregistry/:/tmp/registry --privileged=true  registry

```



## 七、Linux

> 基本命令

```shell
ls:查询文件结构
ls -l
ls -a

ll 查看文件

cat:查看文件内容

# 查看当前路径
pwd（print working directory）: 打印当前工作路径

# 设置IP地址、端口、HDCP
vim /etc/sysconfig/network-scripts/ifcfg-ens33

# 重启服务
systemctl restart network

# 修改主机名
hostnamectl set-hostname 要修改的文件名
```

| 目录                     | 说明                                                     |
| :----------------------- | -------------------------------------------------------- |
| bin                      | 系统文件夹，存放Linux的系统文件                          |
| sbin                     | 超级管理员的系统命令                                     |
| boot                     | 系统所需目录（系统启动相关文件）==                       |
| `etc`                    | 存放系统配置相关的文件（环境变量）                       |
| lib/lib64                | library存放系统所需的依赖库                              |
| `home`                   | 一般用户所在文件夹（此目录包含了所有普通用户的子目录）   |
| `root`                   | 超级管理员目录（root用户目录）                           |
| media                    | 媒体（光驱）                                             |
| mnt                      | 挂载（U盘、移动硬盘）                                    |
| tmp、opt                 | 临时文件存储目录，比如日志存储在tmp或者opt中             |
| `usr`                    | 用户目录，我们通常安装的软件、用户的一些文件都在此目录下 |
| run srv sys var proc dev | 系统相关目录                                             |



### 1.普通模式

```shell
vim:进入普通模式
u:撤销
yy:复制
p:粘贴
dd:删除行
i:替换
(数字) + G:跳转到指定行
```

### 2. 编辑模式

```xml
i、o、a:进入编辑模式
```

### 3. 命令行模式

```shell
:w 			保存
:q 			退出
:wq 		保存退出
:q! 		退出不保存
:set nu 	显示行号
:set nonu 	关闭行号
/要查找的词  	 n 查找下一个,N 往上查找
:s/old/new 		替换当前行匹配到的第一个old为new
:s/old/new/g 	替换当前行所有的old为new
:%s/old/new		替换文档中每一行匹配到的第一个old为new
:%s/old/new/g	替换文档中每一行所有的old为new
```

### 4. 关机重启命令

```shell
sync		将数据有内存同步到硬盘

halt		停机，关闭系统，但不断电

poweroff	关机，断电

reboot		重启 = shutdown -r now

shutdown[选项] 时间	
	
```

### 5. shell命令

#### 5.1四大命令

> 创建、复制、删除、移动

```shell
mkdir + 目录名称 :创建目录
touch + 文件名称 :创建文件夹
cp[选项] source(源文件) dest(目标文件): 复制文件或目录
	-r 递归复制整个文件夹
rm[选项] file:移除
	-r	递归删除目录中所有内容
	-f	强制执行删除操作，而不是提示用于进行确认
	-v	显示指令的详细执行过程
mv oldFile newFile : 重命名
mv /temp/movefile /targetFolder :移动文件
```

#### 5.2 more 文件内容分屏查看器

```shell
基本命令
more fileName 

```

####  5.3 less 分屏显示文件内容

```shell
基本命令
less fileName
```

|    操作    |        功能说明        |
| :--------: | :--------------------: |
|   空白键   |      向下翻动一页      |
| [pagedown] |      向下翻动一页      |
|  [pageup]  |      向上翻动一页      |
|  /字符串   | 向下搜寻【字符串】内容 |
|  ？字符串  | 向上搜寻【字符串】内容 |
|     q      |   离开less这个程序;    |

#### 5.4 echo

```shell
echo[选项][输出内容]
	-e:	支持反斜线控制的字符转换
```

| 命令 |        说明         |
| :--: | :-----------------: |
| \ \  |      输出\本身      |
| \ n  |      换行输出       |
| \ t  | 制表符，也就是tab键 |

#### 5.5 > 输出重定向和 >> 追加

```shell
ls -l > 文件    	列表内容，覆盖写
ls -al >> 文件	列表内容，追加到文件末尾
cat 文件1 > 文件2
echo “内容” >> 文件
```

#### 5.6 head 显示文件头部内容

```shell
head 文件		查看文件头10行内容
head -n 5 文件		查看文件头五行内容，5是任意数
```

#### 5.7 tail 输出文件尾部内容

```shell
tail 
```

#### 5.8 ln 软连接

```shell
ln -s [源文件或目录][软连接名]	功能：给源文件创建一个软连接
rm -f 	功能：删除软连接
rm -rf  功能:会把软连接对应的真实目录下内容删除
```



#### 5.9 时间日期类

```shell
date[option]...[+format]
	-d 
	-d '1 days ago' : 显示前一天信息
	-d '-1 days ago' :显示明天信息
	-s 字符串时间 例：date -s "2022-05-13 10:10:10"
```

### 6.用户管理命令

#### 6.1 useradd 添加新用户

```shell
useradd 用户名			功能：添加新用户
useradd -g 组名 用户名	功能：添加新用户到某个组

passwd 	功能：添加密码

```

#### 6.2 chmod 更改用户权限

```shell
d rwx rwx rwx
d user group others
d u g o

第一种方式 
chmod u+x/u-x 文件或目录
第二种方式
chmod [mode=421] [文件或目录]
```

#### 6.3 chgrp 改变所属组

#### 6.4 chown 改变

#### 6.5 find

> 查找文件

```shell
find -name [fileName]
find -name "*.txt" 查找以.txt结尾的所有文件
find -size +10M 
```

#### 6.6 Locate

> 定位文件

```shel
#查询文件夹
locate [fileName] 
updatedb
```

#### 6.7 grep

> 过滤查找及“”管道符

```shell
grep [选项] 查找内容 源文件
	-n 显示匹配行及行号
```

### 7. 文件压缩

### 7.1 gzip/gunzip 

> 压缩与解压缩

```shell
gzip文件    	 压缩文件，只能将文件压缩为*.gz文件
gunzip文件gz   解压缩文件命令
```

#### 7.2 zip/unzip

> 压缩与解压缩

```shell
zip -r 压缩目录
unzip -d 指定解压后文件的存放地址
```

#### 7.3 tar

> 打包与解包

```shell
tar [选项] xxx.tar.gz 将要打包进去的内容       功能描述：打包目录，压缩后的文件格式.tar.gz
	选项 -c	   产生.tar打包文件
		-v	 	显示详细信息
		-f		指定压缩的文件名
		-z		打包同时压缩
		-x		解包.tar文件
		-C		解压到指定目录
		压缩 tar -zcvf temp.tar.gz 我的学习内容.txt ls
		解压 tar -zxvf temp.tar.gz
```

#### 7.4 du

> 查看文件和目录占用的磁盘空间

```shell
du: disk usage 磁盘占用情况

du 目录/文件   功能：显示目录下每个子目录的磁盘使用情况
	-h	以人们较易读的GBytes，MBytes，KBytes等格式自行显示
	-a	不仅查看子目录大小，还要包括文件
	-c	显示所有的文件和子目录大小后，显示总和
	-s	只显示总和
	--max-depth=n	指定统计子目录的深度为第n层
	
df:disk free 空余磁盘

df [选项]		功能：列出文件系统的整体磁盘使用量，检查文件系统的磁盘使用空间占用情况
	-h  以人们较易读的GBytes，MBytes，KBytes等格式自行显示
```

#### 7.5 lsblk

> 查看设备挂在情况

```shell
lsblk 
	-f 查看详细的设备挂载情况，显示文件系统信息
```

#### 7.6 fdisk

> 分区

```shell
fdisk -l 功能：查看磁盘分区详情
fdisk 硬盘设备名 功能：对新增磁盘进行分区操作
	-l x
```



## 8. 系统管理

#### 8.1 service

> 服务管理

#### 8.2 ps

> 查看当前系统进程状态

```shell
ps：process status 进程状态

ps aux | grep xxx  	查看系统中所有进程
ps -ef | grep xxx	根据进程名查询进程，可以查看子父进程之间的关系
	选项  a 列出带有终端的虽有用户的进程
		 x	列出当前用户的所有进程，包括没有终端的进程
		 u	面向用户有好的显示风格
		-e	列出所有进程
		-u	列出某个用户的所有进程
		-f	显示完整格式的进程列表
		
netstat -apn | grep port 通过端口查询进程信息

lsof -i:port 查看正在运行的进程信息
```

|  属性   |                             说明                             |
| :-----: | :----------------------------------------------------------: |
|   PID   |                          进程的ID号                          |
|  %cpu   |    该进程占用cpu资源的百分比，占用的越高，进程越耗费资源     |
|  %MEN   |    该进程占用物理内存的百分比，占用的越高，进程越耗费资源    |
|   VSZ   |             该进程占用实际物理内存的大小，单位KB             |
|   RSS   |             该进程占用实际物理内存的大小，单位KB             |
|   TTY   | 该进程是在哪个终端中运行的。对于CentOS来说，tty1是图形化终端，tty2-tty6是本地的字符界面终端。pts/0-255代表虚拟终端 |
|  STAT   | 进程状态。常见的状态有：R：进行状态，S：睡眠状态，T：暂停状态，Z：僵尸状态，s：包含子进程，l：多线程，+：前台显示 |
|  START  |                       该进程的启动时间                       |
|  TIME   |          该进程占用cpu的运算时间，注意不是系统时间           |
| COMMAND |                      产生此进程的命令名                      |

#### 8.3 kill

> 杀掉进程

 ```shell
kill [选项] 进程号		通过进程号杀死进程
killall 进程名称		通过进程名称杀死进程，也支持通配符，这在系统因负载过大二变很慢时很有用
	-9 表示强迫进程立即停止
 ```

#### 8.4 pstree

> 查看进程树

```shell
pstree
```

#### 8.5 top

> 实时监控系统进程状态

```shell
top [选项] 
	【选项】
	-d 秒数	指定top命令每隔几秒更新，默认是3秒在top命令的交互模式当中可以执行的命令：
	-i	使top不显示任何限制或者僵死的进程
	-p	通过指定监控进程ID来仅仅监控某个进程的状态
	
ps: top -i:port 通过端口查询进程信息
		
	
```

|   操作    |         说明          |
| :-------: | :-------------------: |
| shift + P | 以cpu使用率排序，默认 |
|  shift+M  |  以内存的使用率排序   |
|  shift+N  |       以PID排序       |
|  shift+g  |        退出top        |

#### 8.6 netstat

> 显示网络状态和端口占用信息

```shell
netstat -anp | grep 进程号 	查看改进程网络信息
netstat -nlp | grep 端口号		查看端口号占用情况
```

| 选项 |                     功能描述                     |
| :--: | :----------------------------------------------: |
|  -a  | 显示正在监听（listen）或未监听（socket）的套接字 |
|  -n  |     拒绝显示别名，能显示数字的全部转化成数字     |
|  -l  |              仅列出在监听的服务状态              |
|  -p  |              表示显示那个进程在调用              |

#### 8.7 crontab系统定时任务

```shell
重新启动crond服务
systemctl restart crond

crond [选项]
```

| 选项 | 功能                          |
| ---- | ----------------------------- |
| -e   | 编辑crontab定时任务           |
| -l   | 查询crontab任务               |
| -r   | 删除当前用户所有的crontab任务 |

### 9. 软件包管理

#### 9.1 RPM

> RPM(RedHat Package Manager)



##### 9.2.1 rpm 查询命令

>  rpm  -qa | grep  关键字		查询所安装的rpm软件包



##### 9.3.2 rpm 卸载命令

> -  rpm -e rpm 软件包	卸载软件包
> -  rpm -e --bodeps 软件包		卸载时不检查依赖，这样的话那些使用该软件包的软件再次之后可能就能正常工作了



##### 9.4.3 rpm 安装命令

> rpm -ivh RPM包全名



##### 9.4.4 rpm 更新命令

> rpm -uvh 安装包.rpm (更新安装包)

|   选项   |          功能          |
| :------: | :--------------------: |
|    -i    |      install,安装      |
|    -v    | --berbose,显示详细信息 |
|    -h    |     --hash，进度条     |
| --nodeps |    安装前不检查依赖    |



#### 9.2 YUM

> yum [选项] [参数]

| 选项 |         功能          |
| :--: | :-------------------: |
|  -y  | 对所有提问都回答“yes” |

|     参数     |             功能              |
| :----------: | :---------------------------: |
|   install    |         安装rpm软件包         |
|    update    |         更新rpm软件包         |
| check-update | 检查是否有可用的更新rpm软件包 |
|    remove    |      删除指定的rpm软件包      |

### 10. 定义变量

```shell
export 变量名 ： 定义全局变量
```

#### 10.1 特殊变量

```shell
$n    n是1~9数字

$#:	获取所有输入参数个数，常用语循环判断参数的个数是否争取以及加强脚本的健壮性

$*: 这个变量代表哦命令行中所有的参数，$*把所有的参数看成一个整体
$@: 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待

$?: 最后一次执行的命令的返回状态
```

#### 10.2 运算符

```shell
expr ? + ? 
$(())或$[]

```

#### 10.3 条件判断

``` 
test $a = hello
echo $?

[ condition ](前后要有空格)---------->[ 2 = 2 ]     echo $? 0相同 1不相同
echo $?

整数之间比较
-eq (equal) 相等 
-ne (not equal) 不等
-lt (less than) 小于
-le (less equal) 小于等于
-gt (greater than) 大于
-ge (greater equal) 大于等于


权限判断
-r	读权限------->[ -r filename ] 
-w	写权限------->[ -w filename ]
-e	执行权限----->[ -e filename ]

文件类型判断
-f
-d

逻辑运算
&& 与运算
|| 或运算

```

#### 10.4 流程控制（重点）

##### 10.4.1 if判断

```shell
(1)单分支
if[ 条件判断式 ];then 
程序
fi

if[ 条件判断式 ] 
then
	程序
else[ 条件判断式 ]
	程序
fi

(2)多分支
if[ 条件判断式 ]
    then
        程序
    elif
    then 
        程序
    else
    then 
        程序
fi
```

##### 10.4.2 case语句

```shell
case $变量名 in
"值 1")
	如果值为1，执行程序1
;;
"值 2")
	如果值为2，执行程序2 
;;
*)
	如果都不是,则执行此程序	
;;
esac
```

##### 10.4.3 for循环

```shell
for (( 初始值;循环控制条件;变量变化 ))
do
	程序
done

for () in $
```

##### 10.4.4 while循环

```shell
while [ 条件判断式 ]
do
	程序
done
```

### 11. read读取控制台输入



### 12. 函数

#### 12.1 系统函数

```shell
basename [string/pathname][suffix] 	basename会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。

basename 可以理解为取路径里的文件名称	

suffix 为后缀，如果后缀suffix被指定了basename会将string/pathname的suffix去掉


dirname	文件的绝对路径


function funname()
{
	Action;
	return int;
}
```

### 13.文本处理工具

#### 13.1 cut

```shell
cut 的工作就是“剪”

cut [选项参数] filename
默认分隔符是制表符
```

| 选项参数 |                        功能                        |
| :------: | :------------------------------------------------: |
|    -f    |                  列号，提取第几列                  |
|    -d    |  分割符，按照指定分隔符分割列，默认是制表符“\t”l   |
|    -c    | 按分隔符进行切割 后面追加加n表示第几列   比如 -c 1 |

#### 13.2 awk

>  将文件逐行的读入，以空格为默认分割符每行切片，切开的部分在进行分析处理

```shell
awk [选项参数]  '/patten1/{action1} /pattern2/{action2}...' filename
	pattern：表示awl在数据中查找的内容，就是匹配模式
	action：在找到匹配内容是所执行的一系列命令
	-F	指定输入文件分隔符
	-v 赋值一个用户定义变量
```



### 14.下载MySQL、jdk



#### 14.1 jdk安装

##### 14.1.1 jdk在线安装

**1.在线下载jdk安装包**

```shell
[root@localhost local]# wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie"  http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz
```



**2.解压安装包**

```shell
cd /usr/local/

tar -zxvf  安装包.tat.gz
```



##### 14.1.2 jdk离线安装

**1.官网下载JDK安装包**

>  http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz

**2.解压安装包**

> cd /usr/local/
>
> tar -zxvf  安装包.tat.gz

**3.配置环境变量**

> vim /etc/profile

```shell
#z
export JAVA_HOME=/usr/local/jdk1.8.0_333
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib
export PATH=$JAVA_HOME/bin:$PATH
```



#### 14.2 安装Tomcat

> **1.解压安装包**

```properties
tar -zxvf 安装包.tat.gz
```



> **2.运行Tomcat**

```properties
./startup.sh
```



#### 14.3 安装MySQL

> **1.下载安装包**

```properties
[root@localhost local]# wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
```



> **2.安装MySQL安装源**

```properties
[root@localhost local]#  yum -y localinstall mysql57-community-release-el7-11.noarch.rpm 
```



> **3.在线安装MySQL**

```properties
[root@localhost local]# yum -y install mysql-community-server
```



> **4.启动MySQL服务**

```properties
[root@localhost local]# systemctl start mysqld

[root@localhost local]# systemctl stop mysqld
```



> **5.设置开机自启动**

```properties
[root@localhost local]# systemctl enable mysqld
[root@localhost local]# systemctl daemon-reload
```



> **6.查看root登陆密码**

```properties
cat mysqld.log  | grep password
```



> **7.使用默认密码登录**

```properties
> #登录
>
> [root@localhost local]# mysql -u root -p
>
> #修改密码
>
> mysql> set global validate_password_policy=0;
>
> mysql> set password=password("abc123");
```



-  如果此时出现下面错误

```properties
ERROR 1819 (HY000): Your password does not satisfy the current policy requirements

- 设置默认密码长度8位
  - mysql> set password=password("12345678");
  - show variables like 'validate_password%';
```

![](../../../CodeManager/Snipaste/Snipaste_2022-06-19_15-21-08.png)

```properties
- mysql> set global validate_password_length=6;
- mysql> set password=password("abc123");
- mysql> exit
  Bye
```

<img src="../../../CodeManager/Snipaste/Snipaste_2022-06-19_15-22-34.png"  />



> 设置远程登录

```properties
mysql> GRANT ALL PRIVILEGES ON *.* TO 'root''@'%' IDENTIFIED BY 'abc123' WITH GRANT OPTION;

mysql> flush PRIVILEGES;
```



> **8.设置防火墙，开放数据库远程访问端口**

```properties
[root@localhost sysconfig]# cd /etc/sysconfig/
[root@localhost sysconfig]# vim iptables

# 添加代码
-A INPUT -p tcp --dport 3306 -j ACCEPT
```



> **9.重启防火墙**

```properties
[root@localhost sysconfig]# service iptables  restart
```



> **10.配置MySQL字符编码**

```properties
[root@localhost sysconfig]# vim /etc/my.cnf

#添加如下代码

character_set_server=utf8
init_connect='SET NAMES utf8'
```



>  **11.重启MySQL**

```properties
[root@localhost data]# systemctl restart mysqld
```

#### 14.4 安装Nginx

**1.安装编译工具**

```properties
[root@hadoop100 local]# yum -y install gcc gcc-c++
```

**2.安装PCRE**

```properties
# 1.下载
[root@hadoop100 local]# wget https://downloads.sourceforge.net/project/pcre/pcre/8.40/pcre-8.40.tar.gz

#2.解压
[root@hadoop100 local]# tar -zxvf pcre-8.40.tar.gz

#3.进入pcre目录
[root@hadoop100 local]# cd pcre-8.40/

#4.配置
[root@hadoop100 pcre-8.40]# ./configure 

#5.编译安装
[root@hadoop100 pcre-8.40]# make && make install

```

**3.安装SSL库**

```properties
 cd /usr/local

#1. 下载
[root@hadoop100 local]# wget http://www.openssl.org/source/openssl-1.0.1j.tar.gz

#2. 解压
[root@hadoop100 local]# tar -zxvf opensal-1.0.1j.tar.gz

#3. 进入opensal目录
[root@hadoop100 local]# cd opensal-1.0.1j

#4. 配置
[root@hadoop100 openssl-1.0.1j]# ./config

#5 编译安装
[root@hadoop100 openssl-1.0.1j]# make && make install

```

**4.安装zlib库**

```properties
 cd /usr/local
 
 #1. 下载
[root@hadoop100 local]# wget http://zlib.net/zlib-1.2.12.tar.gz

#2. 解压
[root@hadoop100 local]# tar -zxvf zlib-1.2.12.tar.gz

#3. 进入zlib目录
[root@hadoop100 local]# cd zlib-1.2.12

#4. 配置
[root@hadoop100 openssl-1.0.1j]# ./configure

#5 编译安装
[root@hadoop100 openssl-1.0.1j]# make && make install
```

**5.安装Nginx**

```properties
 cd /usr/local

 #1. 下载
[root@hadoop100 local]# wget http://nginx.org/download/nginx-1.22.0.tar.gz

#2. 解压
[root@hadoop100 local]# tar -zxvf nginx-1.22.0.tar.gz

#3. 进入nginx目录
[root@hadoop100 local]# cd nginx-1.22.0/


#4. 创建服务目录
[root@hadoop100 nginx-1.22.0]# mkdir -p /usr/local/server/nginx
#5. 配置
[root@hadoop100 nginx-1.22.0]# ./configure --prefix=/usr/local/server/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/pcre-8.40

# 如果配置出现错误
./configure: error: SSL modules require the OpenSSL library.
You can either do not enable the modules, or install the OpenSSL library
into the system, or build the OpenSSL library statically from the source
with nginx by using --with-openssl=<path> option.
#执行下面语句
yum -y install openssl openssl-devel

#6. 编译安装
[root@hadoop100 openssl-1.0.1j]# make && make install

#7. 运行
```

![](../../../CodeManager/Snipaste/Snipaste_2022-06-20_10-48-41.png)

















## 其他、ES6、Vue

### 6.1 es6语法

```javascript
let p1={name,age} //定义对象

const 定义常量

let person1 = {
    function(){
        
    }
}

对象和并
let p1 = {"name":"kkk","age": 20}
let p2 = {"name":"kkk","age": 20}
let p1 = {...p2}


文件 666.js
export default{
    getList(){
        console.log("获取数据1");
    }
    
    save(){
        console.log("获取数据2");
    }
}


文件 777.js
导入模块
import mmm from "./666.js"'
mmm.getList()
mmm.save()

```

#### 6.1.1 webpack

```shell
//安装webpack
npm install -g webpack webpack-cli

//安装css加载器
npm install --save-dev style-loader css-loader

//升级 npm 至 v7.6.2 后, 运行 npm i 安装依赖，报错 ERESOLVE unable to resolve dependency tree
使用 npm i --legacy-peer-deps


cmd中输入 node -v


启动项目
npm install

npm run dev
```

![image-20220519075531334](https://raw.githubusercontent.com/kristenli0116/repo/main/img/image-20220519075531334.png)
